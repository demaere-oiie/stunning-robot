{
  "traces": [],
  "train": [],
  "demos": [
    {
      "augmented": true,
      "target": "You are a coding agent that programs in Beltabol, a novel programming language. The documentation follows:\n# Da Beltabol fong but fo gova\n\nThis file is a bottom-up introduction to Beltabol, a novel eager functional language.\n\n## Built-in Datatypes and simple Expressions\n\nBeltabol currently has four built-in datatypes: integers, strings, lists, and sets. All can be treated in a basic fashion, operating upon each value as a whole, or (in an advanced fashion) can be further analyzed into parts: integers into bits, strings into strings of length 1, and lists and sets into any datatype.\n\nLimitation: Beltabol does not have a tuple type, but as there is no type checking, lists can be used instead.\n\n### Basics of Integers\n\nBeltabol integers, like `0` or `42`, have the usual arithmetic operations with the usual precedence: `+`, `-`, `*`, and `/`. The last is integer division, so `5/2 == 2`.\n\nThey are also totally ordered, and have the usual set of relational operators: `<`, `<=`, `==`, `>=`, `>`, and `<>`. The relational operators produce integer `0` for false and integer `1` for true.  Nota Bene: all values, not only integers, can only be compared to values of the same type; all relational operators return 0 if given arguments of distinct types.\n\nLimitation: for the time being, only decimal literals work.\n\nLimitation: in principle, integers are multiple precision; at the current time, they are rpython ints, which wrap at a given bitwidth.\n\n### Basics of Strings\n\nBeltabol strings, like `\"foo\"` or `\"Oye, setara setara!\"` can be concatenated with the `:=:` operator, which is left associative and has precedence just below the arithmetic operators. The empty string is `\"\"` and is the identity for `:=:`.\n\nStrings are totally ordered in lexicographical order.\n\nLimitation: currently, `ord` and `chr` are defined via a lookup table in the standard prelude, so they only have the printable ASCII range.\n\nLimitation: currently there are no string escapes.\n\n### Basics of Lists\n\nBeltabol lists, like `[]` or `[0, \"wang\", []]`, are sequences of items of any beltabol type, including other lists. They can also be concatenated with `:=:`. The empty list is `[]` and is the identity for `:=:`.\n\nLists are totally ordered in lexicographical order.\n\n### Basics of Sets\n\nBeltabol sets, like `{}` or `{0, \"nada\", [], {}}` are unordered collections of elements of any beltabol type, including other sets. They can be unioned with `:=:`. The empty set is `{}` and is the identity for `:=:`.\n\nA special kind of set is the map, which has key:value pairs as elements, eg `{\"nada\":0,\"wang\":1,\"tu\":2}`. These act like functions, and when called with an existing key as an argument, return the corresponding value.\n\nSets are partially ordered in inclusion order.\n\n### Advanced Integers\n\nIntegers have a substructure of (little-endian) sequences of bits. They can be synthesized using the `<:` cons operator, whose left hand side must be a bit (0 or 1), which is shifted into the least significant place, eg: `0<:4 == 8` and `1<:4 == 5`.\n\nIntegers may also be analyzed using the `@` indexing operator, which has a higher precedence than the arithmetic operators, and picks out the bit at that place (`n@0` is the least significant bit of `n`)\n\n### Advanced Strings\n\nStrings have a substructure of sequences of length-1 strings. They can be synthesized using the `<:` cons operator, the `>:` snoc operator, and `:=:`, the splice operator. Cons prepends a length-1 string to the front of the string, snoc appends a length-1 string to the back, and splice concatenates two strings, eg: `\"b\"<:\"elta\" == \"belta\"`; `\"belt\">:\"a\" == \"belta\"`; and `\"bel\":=:\"ta\" == \"belta\"`.\n\nStrings may also be analyzed using the `@` indexing operator, which picks out the length-1 string at that place. (`\"foobar\"@1` == \"o\"`)\n\n### Advanced Lists\n\nLists have a substructure of sequences of items, of any beltabol datatype.  They can be synthesized using the `<:` cons operator, the `>:` snoc operator, and `:=:`, the splice operator, eg: `0<:[\"wang\", []] == [0,\"wang\",[]]`; `[0,\"wang\"]:>[] == [0,\"wang\",[]]`; and `[0]:=:[\"wang\",[]] == [0,\"wang\",[]]`.\n\nLists may also be analyzed using the `@` indexing operator, which picks out the item at that place. (`[0,\"wang\",[]]@2 == []`)\n\n### Advanced Sets\n\nSets have a substructure of unordered collections of elements, of any beltabol datatype. They can be synthesized using the `<:` cons operator and `:=:`, the splice operator. Because of commutativity, the `:>` snoc operator is equivalent to cons on sets. Some examples: `{0,1}:={0,2} == {0,1,2}`; `0<:{1,2} == {0,1,2} == {1,2}:>0`.\n\nSets in general may not be analyzed with the `@` indexing operator, but in the special case of maps being indexed by one of their keys, the operation evaluates to the value corresponding to that key, eg: `{\"nada\":0,\"wang\":1,\"tu\":2}@\"wang\" == 1`.\n\n## User-defined Algebraic Datatypes\n\nUser-defined algebraic datatypes have an constructor, which is an identifier, and arguments of any Beltabol datatype; eg. in `Ptr(s,n)` `Ptr` is the constructor and `s` and `n` are arguments.\n\nExample:\n```\nDa RetBelek imalowda Kuku() | Not(weting,gosh,val,richa).\n\nDa sh(n) im chu\n   \"\"                        detim n?=Kuku();\n   \"(\":=:sh(a):=:x:=:sh(b):=:\")\" detim n?=Not(\"B\",a,x,b);\n   \"<\":=:sh(a):=:x:=:sh(b):=:\">\" detim n?=Not(\"R\",a,x,b).\n```\n\nLimitation: in principle, the algebraic datatypes are totally ordered, but this is currently unimplemented.\n\n## Functions\n\nFunctions can be synthesized via composition with `,`, but they cannot be analyzed: apart from passing them to higher-order functions, the only thing to do with them is to apply them to arguments, either via the high-precedence usual syntax `f(x)`, or via the much-lower precedence `f $ x`. Examples: `(f,g)(x) == f(g(x)) == (f $ g $ x)`\n\n(More pedantically, when we say \"functions\" we are really talking about the *closures* to which they evaluate)\n\nOperators behave like two-argument functions; To use an operator as an identifier, enclose it in parens, eg `(+)`. To use an identifier as an operator, enclose it in backticks, eg `` `mod` ``.\n\n## Compound Expressions\n\nThere are two compound expressions, `chu` compounds and `fong` compounds.\n\n```\n    defn : CHU {cdecl SEMIC} cdecl\n    defn : FONG expr {rdecls SEMIC} rdecls\n```\n\nWhen compound expressions occur as subexpressions anywhere but in top-level statements, they must be fully parenthesized, eg: `2*(chu 2 detim p; 0 detim owta)`\n\n```\nDa div(n,m) im chu\n    (fong (chu [q#1, r-m] detim m<=r;\n               [q#0, r  ] detim owta)\n        wit [q,r] deting div(n,m#0)) detim m<=n;\n               [  0, n  ]            detim owta.\n```\n\n### Chu\n\n`Chu` is like Lisp's COND; each `cdecl` is of the form `expr DETIM guard` and evaluates the expression whose guard is the first to evaluate to 1.\n\nThe match operator, `?=`, which has a low precedence, may be used to extend the expression's environment. It takes a value on its left hand side, and a pattern on its right, and attempts to bind variables in the pattern in such a way as to match the value.\n\nGuards may be composed of multiple clauses, joined by the low-precedence `&&` and operator: ``(x `rep` ys) detim xs?=[x] && len(ys)==1;``\n\n### Example patterns using the `?=` match operator\n\nInteger matching: `0 detim n?=42;` or `m+mul(h,0<:m) detim n?=1<:n;`\n\nString matching: `1 detim arg?=\"-v\";` or `len(h)+len(t) detim s?=h:=:t;`\n\nList matching: `0 detim xs?=[];` or `dfs(graph, h<:seen, acc:>h, vedi(graph,h):=:t) detim vs?=h<:t;`\n\nSet matching: `0 detim xs?={};` or `dfs(graph, seen, acc, t) detim vs?=h<:t && seen?=h<:_ ;`\n\nNote that the clauses of a `chu` expression are always of the form `expression detim guard`.\n\n### Fong\n\n`Fong` is a bit like Lisp's LET; each `rdecl` is of the form `WIT binding DETING expr` where `binding` is bound to the value of `expr`.\n\nWhen there are multiple bindings, each `expr` can see the bindings which come below (after) it.\n\n```\nDu chek (fong cclvi*cclvi\n  wit cclvi deting xvi*xvi;\n  wit xvi   deting iv*iv;\n  wit iv    deting ii*ii;\n  wit ii    deting 2)\nim 65536.\n```\n\nTo define functions, `binding` should be of the form `id(arguments...)`, as in the definition of `nawit(y,xs)` following:\n\n```\nDa nub(xs) im fong (chu\n    h<:nub(nawit(h,t)) detim xs?=h<:t;\n    []                 detim owta)\n    wit nawit(y,xs) deting (chu\n        (chu  nawit(y,t) detim h==y;\n           h<:nawit(y,t) detim owta) detim xs?=h<:t;\n         []                          detim owta).\n```\n\nIn general, what in another language might be written as `let y=z in let v=w in x` would be expressed in Beltabol as `(fong x wit v deting w; wit y deting z)`. Note the change in order!\n\n### Fong/delowda for list comprehensions\n\nUsing `delowda` instead of `deting` turns a `fong` compound expression into a list comprehension.\n\n```\nDa flatten(xss) im fong x\n    wit x  delowda xs;\n    wit xs delowda xss.\n\nDu chek flatten([[0],[],[1,2]]) == [0,1,2].\n```\n\nIn general, what in another language might be written as `[x | y<-z, v<-w]` would be expressed in Beltabol as `(fong x wit v delowda w; wit y delowda z)`. Note the change in order! To produce the effect of a guard, either use a `delowda` clause which evaluates to either a length-0 list for failure or length-1 list for success, or use a refutable pattern in the binding position of the `WIT binding DELOWDA expression` clause.\n\nNote that one can mix `deting` and `delowda` clauses within a single `fong`; the delowdas will act to multiply results but the detings always introduce a single binding (per the delowda's underneath them) only. As is usual with the list monad, a fong comprehension expression produces a flattened list of results, no matter how many delowda clauses it has.\n\n```\nDu chek (fong z\n  wit z deting 2*y;\n  wit y delowda [x+1,x-1];\n  wit x delowda [z+1,z+2];\n  wit z deting 0) im [4,0,6,2].\n```\n\n### Fong/unte for mutual recursion\n\nUse `unte` between `wit` definitions for mutual recursion:\n```\n(fong even(4)\n  wit even(n) deting (chu 1        detim n==0;\n                          odd(n-1) detim owta)\n  unte\n  wit odd(n) deting (chu 0         detim n==0;\n                         even(n-1) detim owta)).\n```\n\n### Fong/imalowda for local algebraic types\n\n```\n(fong dubik(\"\",eg) == gut\n  wit eg         deting [Lit(\"a\"),Ptr(0,5),Lit(\"b\"),Ptr(4,6)];\n  wit gut        deting \"aaaaaabaabaab\";\n  wit dubik(a,c) deting (chu\n        dubik(a<:v  ,              t) detim c?=Lit(v)  <:t;\n        dubik(a     ,              t) detim c?=Ptr(s,0)<:t;\n        dubik(a<:a@s,Ptr(s+1,n-1)<:t) detim c?=Ptr(s,n)<:t;\n              a                       detim owta);\n  wit Mali       imalowda Lit(v) | Ptr(s,l))\n\n```\n\n### Important! Fong Expression Evaluation Order \nIn Beltabol, `fong` expressions (similar to let expressions in other languages) have a unique evaluation order that's opposite to their visual presentation order. \n\n*Key Rule:* bindings in a `fong` expression are evaluated *from bottom to top*, not top to bottom as might be expected from reading order. \n\n```\nDa lookup(table, key) im \n    fong find_in_bucket(bucket, key) // Evaluated Last\n    wit bucket deting table@index; // Evaluated Next\n    wit index deting hash(key). // Evaluated First\n```\n\nThis is to give a top-down overview of the code: emphasizing the forest, not the trees.\n\n## Statements\n\nThere are four statements:\n```\n    statement : DA expr IM defn DOT      \n    statement : DA expr IMALOWDA expr DOT \n    statement : DU CHEK expr IM expr DOT  \n    statement : SHOWXA defn DOT           \n```\n\n1. `Da ... im ...` binds definitions (at the top level)\n2. `Da ... imalowda ...` creates algebraic datatypes\n3. `Du chek ... im ...` is an equality test (run with `--test` option)\n4. `Showxa ...` is used for print debugging\n\nLimitation: Beltabol currently has no I/O; if streams are ever implemented, then probably `Mesach ...` will provide bytestream output)\n\n```\nDa four im 2+2.\nDa peano imalowda Zero | Succ(n).\nDu chek four im 4.\nShowxa Succ(Succ(Zero)).\n```\n\nNote that compound expressions need not be parenthesized when occuring as `defn`s in the `Da/im` and `Showxa` statements, eg:\n\n```\nDa fak(n) im chu\n    n*fak(n-1) detim 1<=n;\n    1          detim owta.\n```\n\nHowever, statements *always* end with `.`.\n\n## Comments\n\nLine comments go from an opening `//` to the end of line.\n\n## Standard prelude\n\n|name|purpose|\n|----|-------|\n|owta| 1 (True)|\n|max(x,y)|**max**imum of **x** and **y**|\n|mebi(f)|returns fn returning x if f(x) fails, otherwise f(x)|\n|walowda(f)|returns fn returning the least fixpoint of **f**(**f**(...**f**(x)...))|\n|sqrt(n)|integer square root of **n**||\n|mod(i,j)|i **mod** j|\n|len(v)|length of **v**alue|\n|chr(n)|length-1 string with numeric value **n**||\n|ord(c)|numeric value of length-1 string **c**|\n|unit(v)|returns empty string or list as **v** is string or list||\n|(**)(b,e)|raises int **b**ase to **e**xponent|\n\n## See also\n\nSee the [other docs](bb.md) and the [brief introduction](https://drive.google.com/file/d/1zTGjy9KeW4cqagXHlVDwKmcZ1mEz6u-K/view).\n",
      "task": "Please write factorial.\nPlease use `Du chek` to check your program",
      "program": "Da fak(n) im chu\n    n*fak(n-1) detim 1<=n;\n    1          detim owta.\n\nDu chek fak(5) im 120.\nDu chek fak(0) im 1.\nDu chek fak(1) im 1.\nDu chek fak(3) im 6."
    },
    {
      "augmented": true,
      "target": "You are a coding agent that programs in Beltabol, a novel programming language. The documentation follows:\n# Da Beltabol fong but fo gova\n\nThis file is a bottom-up introduction to Beltabol, a novel eager functional language.\n\n## Built-in Datatypes and simple Expressions\n\nBeltabol currently has four built-in datatypes: integers, strings, lists, and sets. All can be treated in a basic fashion, operating upon each value as a whole, or (in an advanced fashion) can be further analyzed into parts: integers into bits, strings into strings of length 1, and lists and sets into any datatype.\n\nLimitation: Beltabol does not have a tuple type, but as there is no type checking, lists can be used instead.\n\n### Basics of Integers\n\nBeltabol integers, like `0` or `42`, have the usual arithmetic operations with the usual precedence: `+`, `-`, `*`, and `/`. The last is integer division, so `5/2 == 2`.\n\nThey are also totally ordered, and have the usual set of relational operators: `<`, `<=`, `==`, `>=`, `>`, and `<>`. The relational operators produce integer `0` for false and integer `1` for true.  Nota Bene: all values, not only integers, can only be compared to values of the same type; all relational operators return 0 if given arguments of distinct types.\n\nLimitation: for the time being, only decimal literals work.\n\nLimitation: in principle, integers are multiple precision; at the current time, they are rpython ints, which wrap at a given bitwidth.\n\n### Basics of Strings\n\nBeltabol strings, like `\"foo\"` or `\"Oye, setara setara!\"` can be concatenated with the `:=:` operator, which is left associative and has precedence just below the arithmetic operators. The empty string is `\"\"` and is the identity for `:=:`.\n\nStrings are totally ordered in lexicographical order.\n\nLimitation: currently, `ord` and `chr` are defined via a lookup table in the standard prelude, so they only have the printable ASCII range.\n\nLimitation: currently there are no string escapes.\n\n### Basics of Lists\n\nBeltabol lists, like `[]` or `[0, \"wang\", []]`, are sequences of items of any beltabol type, including other lists. They can also be concatenated with `:=:`. The empty list is `[]` and is the identity for `:=:`.\n\nLists are totally ordered in lexicographical order.\n\n### Basics of Sets\n\nBeltabol sets, like `{}` or `{0, \"nada\", [], {}}` are unordered collections of elements of any beltabol type, including other sets. They can be unioned with `:=:`. The empty set is `{}` and is the identity for `:=:`.\n\nA special kind of set is the map, which has key:value pairs as elements, eg `{\"nada\":0,\"wang\":1,\"tu\":2}`. These act like functions, and when called with an existing key as an argument, return the corresponding value.\n\nSets are partially ordered in inclusion order.\n\n### Advanced Integers\n\nIntegers have a substructure of (little-endian) sequences of bits. They can be synthesized using the `<:` cons operator, whose left hand side must be a bit (0 or 1), which is shifted into the least significant place, eg: `0<:4 == 8` and `1<:4 == 5`.\n\nIntegers may also be analyzed using the `@` indexing operator, which has a higher precedence than the arithmetic operators, and picks out the bit at that place (`n@0` is the least significant bit of `n`)\n\n### Advanced Strings\n\nStrings have a substructure of sequences of length-1 strings. They can be synthesized using the `<:` cons operator, the `>:` snoc operator, and `:=:`, the splice operator. Cons prepends a length-1 string to the front of the string, snoc appends a length-1 string to the back, and splice concatenates two strings, eg: `\"b\"<:\"elta\" == \"belta\"`; `\"belt\">:\"a\" == \"belta\"`; and `\"bel\":=:\"ta\" == \"belta\"`.\n\nStrings may also be analyzed using the `@` indexing operator, which picks out the length-1 string at that place. (`\"foobar\"@1` == \"o\"`)\n\n### Advanced Lists\n\nLists have a substructure of sequences of items, of any beltabol datatype.  They can be synthesized using the `<:` cons operator, the `>:` snoc operator, and `:=:`, the splice operator, eg: `0<:[\"wang\", []] == [0,\"wang\",[]]`; `[0,\"wang\"]:>[] == [0,\"wang\",[]]`; and `[0]:=:[\"wang\",[]] == [0,\"wang\",[]]`.\n\nLists may also be analyzed using the `@` indexing operator, which picks out the item at that place. (`[0,\"wang\",[]]@2 == []`)\n\n### Advanced Sets\n\nSets have a substructure of unordered collections of elements, of any beltabol datatype. They can be synthesized using the `<:` cons operator and `:=:`, the splice operator. Because of commutativity, the `:>` snoc operator is equivalent to cons on sets. Some examples: `{0,1}:={0,2} == {0,1,2}`; `0<:{1,2} == {0,1,2} == {1,2}:>0`.\n\nSets in general may not be analyzed with the `@` indexing operator, but in the special case of maps being indexed by one of their keys, the operation evaluates to the value corresponding to that key, eg: `{\"nada\":0,\"wang\":1,\"tu\":2}@\"wang\" == 1`.\n\n## User-defined Algebraic Datatypes\n\nUser-defined algebraic datatypes have an constructor, which is an identifier, and arguments of any Beltabol datatype; eg. in `Ptr(s,n)` `Ptr` is the constructor and `s` and `n` are arguments.\n\nExample:\n```\nDa RetBelek imalowda Kuku() | Not(weting,gosh,val,richa).\n\nDa sh(n) im chu\n   \"\"                        detim n?=Kuku();\n   \"(\":=:sh(a):=:x:=:sh(b):=:\")\" detim n?=Not(\"B\",a,x,b);\n   \"<\":=:sh(a):=:x:=:sh(b):=:\">\" detim n?=Not(\"R\",a,x,b).\n```\n\nLimitation: in principle, the algebraic datatypes are totally ordered, but this is currently unimplemented.\n\n## Functions\n\nFunctions can be synthesized via composition with `,`, but they cannot be analyzed: apart from passing them to higher-order functions, the only thing to do with them is to apply them to arguments, either via the high-precedence usual syntax `f(x)`, or via the much-lower precedence `f $ x`. Examples: `(f,g)(x) == f(g(x)) == (f $ g $ x)`\n\n(More pedantically, when we say \"functions\" we are really talking about the *closures* to which they evaluate)\n\nOperators behave like two-argument functions; To use an operator as an identifier, enclose it in parens, eg `(+)`. To use an identifier as an operator, enclose it in backticks, eg `` `mod` ``.\n\n## Compound Expressions\n\nThere are two compound expressions, `chu` compounds and `fong` compounds.\n\n```\n    defn : CHU {cdecl SEMIC} cdecl\n    defn : FONG expr {rdecls SEMIC} rdecls\n```\n\nWhen compound expressions occur as subexpressions anywhere but in top-level statements, they must be fully parenthesized, eg: `2*(chu 2 detim p; 0 detim owta)`\n\n```\nDa div(n,m) im chu\n    (fong (chu [q#1, r-m] detim m<=r;\n               [q#0, r  ] detim owta)\n        wit [q,r] deting div(n,m#0)) detim m<=n;\n               [  0, n  ]            detim owta.\n```\n\n### Chu\n\n`Chu` is like Lisp's COND; each `cdecl` is of the form `expr DETIM guard` and evaluates the expression whose guard is the first to evaluate to 1.\n\nThe match operator, `?=`, which has a low precedence, may be used to extend the expression's environment. It takes a value on its left hand side, and a pattern on its right, and attempts to bind variables in the pattern in such a way as to match the value.\n\nGuards may be composed of multiple clauses, joined by the low-precedence `&&` and operator: ``(x `rep` ys) detim xs?=[x] && len(ys)==1;``\n\n### Example patterns using the `?=` match operator\n\nInteger matching: `0 detim n?=42;` or `m+mul(h,0<:m) detim n?=1<:n;`\n\nString matching: `1 detim arg?=\"-v\";` or `len(h)+len(t) detim s?=h:=:t;`\n\nList matching: `0 detim xs?=[];` or `dfs(graph, h<:seen, acc:>h, vedi(graph,h):=:t) detim vs?=h<:t;`\n\nSet matching: `0 detim xs?={};` or `dfs(graph, seen, acc, t) detim vs?=h<:t && seen?=h<:_ ;`\n\nNote that the clauses of a `chu` expression are always of the form `expression detim guard`.\n\n### Fong\n\n`Fong` is a bit like Lisp's LET; each `rdecl` is of the form `WIT binding DETING expr` where `binding` is bound to the value of `expr`.\n\nWhen there are multiple bindings, each `expr` can see the bindings which come below (after) it.\n\n```\nDu chek (fong cclvi*cclvi\n  wit cclvi deting xvi*xvi;\n  wit xvi   deting iv*iv;\n  wit iv    deting ii*ii;\n  wit ii    deting 2)\nim 65536.\n```\n\nTo define functions, `binding` should be of the form `id(arguments...)`, as in the definition of `nawit(y,xs)` following:\n\n```\nDa nub(xs) im fong (chu\n    h<:nub(nawit(h,t)) detim xs?=h<:t;\n    []                 detim owta)\n    wit nawit(y,xs) deting (chu\n        (chu  nawit(y,t) detim h==y;\n           h<:nawit(y,t) detim owta) detim xs?=h<:t;\n         []                          detim owta).\n```\n\nIn general, what in another language might be written as `let y=z in let v=w in x` would be expressed in Beltabol as `(fong x wit v deting w; wit y deting z)`. Note the change in order!\n\n### Fong/delowda for list comprehensions\n\nUsing `delowda` instead of `deting` turns a `fong` compound expression into a list comprehension.\n\n```\nDa flatten(xss) im fong x\n    wit x  delowda xs;\n    wit xs delowda xss.\n\nDu chek flatten([[0],[],[1,2]]) == [0,1,2].\n```\n\nIn general, what in another language might be written as `[x | y<-z, v<-w]` would be expressed in Beltabol as `(fong x wit v delowda w; wit y delowda z)`. Note the change in order! To produce the effect of a guard, either use a `delowda` clause which evaluates to either a length-0 list for failure or length-1 list for success, or use a refutable pattern in the binding position of the `WIT binding DELOWDA expression` clause.\n\nNote that one can mix `deting` and `delowda` clauses within a single `fong`; the delowdas will act to multiply results but the detings always introduce a single binding (per the delowda's underneath them) only. As is usual with the list monad, a fong comprehension expression produces a flattened list of results, no matter how many delowda clauses it has.\n\n```\nDu chek (fong z\n  wit z deting 2*y;\n  wit y delowda [x+1,x-1];\n  wit x delowda [z+1,z+2];\n  wit z deting 0) im [4,0,6,2].\n```\n\n### Fong/unte for mutual recursion\n\nUse `unte` between `wit` definitions for mutual recursion:\n```\n(fong even(4)\n  wit even(n) deting (chu 1        detim n==0;\n                          odd(n-1) detim owta)\n  unte\n  wit odd(n) deting (chu 0         detim n==0;\n                         even(n-1) detim owta)).\n```\n\n### Fong/imalowda for local algebraic types\n\n```\n(fong dubik(\"\",eg) == gut\n  wit eg         deting [Lit(\"a\"),Ptr(0,5),Lit(\"b\"),Ptr(4,6)];\n  wit gut        deting \"aaaaaabaabaab\";\n  wit dubik(a,c) deting (chu\n        dubik(a<:v  ,              t) detim c?=Lit(v)  <:t;\n        dubik(a     ,              t) detim c?=Ptr(s,0)<:t;\n        dubik(a<:a@s,Ptr(s+1,n-1)<:t) detim c?=Ptr(s,n)<:t;\n              a                       detim owta);\n  wit Mali       imalowda Lit(v) | Ptr(s,l))\n\n```\n\n### Important! Fong Expression Evaluation Order \nIn Beltabol, `fong` expressions (similar to let expressions in other languages) have a unique evaluation order that's opposite to their visual presentation order. \n\n*Key Rule:* bindings in a `fong` expression are evaluated *from bottom to top*, not top to bottom as might be expected from reading order. \n\n```\nDa lookup(table, key) im \n    fong find_in_bucket(bucket, key) // Evaluated Last\n    wit bucket deting table@index; // Evaluated Next\n    wit index deting hash(key). // Evaluated First\n```\n\nThis is to give a top-down overview of the code: emphasizing the forest, not the trees.\n\n## Statements\n\nThere are four statements:\n```\n    statement : DA expr IM defn DOT      \n    statement : DA expr IMALOWDA expr DOT \n    statement : DU CHEK expr IM expr DOT  \n    statement : SHOWXA defn DOT           \n```\n\n1. `Da ... im ...` binds definitions (at the top level)\n2. `Da ... imalowda ...` creates algebraic datatypes\n3. `Du chek ... im ...` is an equality test (run with `--test` option)\n4. `Showxa ...` is used for print debugging\n\nLimitation: Beltabol currently has no I/O; if streams are ever implemented, then probably `Mesach ...` will provide bytestream output)\n\n```\nDa four im 2+2.\nDa peano imalowda Zero | Succ(n).\nDu chek four im 4.\nShowxa Succ(Succ(Zero)).\n```\n\nNote that compound expressions need not be parenthesized when occuring as `defn`s in the `Da/im` and `Showxa` statements, eg:\n\n```\nDa fak(n) im chu\n    n*fak(n-1) detim 1<=n;\n    1          detim owta.\n```\n\nHowever, statements *always* end with `.`.\n\n## Comments\n\nLine comments go from an opening `//` to the end of line.\n\n## Standard prelude\n\n|name|purpose|\n|----|-------|\n|owta| 1 (True)|\n|max(x,y)|**max**imum of **x** and **y**|\n|mebi(f)|returns fn returning x if f(x) fails, otherwise f(x)|\n|walowda(f)|returns fn returning the least fixpoint of **f**(**f**(...**f**(x)...))|\n|sqrt(n)|integer square root of **n**||\n|mod(i,j)|i **mod** j|\n|len(v)|length of **v**alue|\n|chr(n)|length-1 string with numeric value **n**||\n|ord(c)|numeric value of length-1 string **c**|\n|unit(v)|returns empty string or list as **v** is string or list||\n|(**)(b,e)|raises int **b**ase to **e**xponent|\n\n## See also\n\nSee the [other docs](bb.md) and the [brief introduction](https://drive.google.com/file/d/1zTGjy9KeW4cqagXHlVDwKmcZ1mEz6u-K/view).\n",
      "task": "Please write gcd.\nPlease use `Du chek` to check your program",
      "program": "Da gcd(a,b) im chu\n    a              detim b==0;\n    gcd(b, a`mod`b) detim owta.\n\nDu chek gcd(48, 18) im 6.\nDu chek gcd(17, 13) im 1."
    },
    {
      "augmented": true,
      "target": "You are a coding agent that programs in Beltabol, a novel programming language. The documentation follows:\n# Da Beltabol fong but fo gova\n\nThis file is a bottom-up introduction to Beltabol, a novel eager functional language.\n\n## Built-in Datatypes and simple Expressions\n\nBeltabol currently has four built-in datatypes: integers, strings, lists, and sets. All can be treated in a basic fashion, operating upon each value as a whole, or (in an advanced fashion) can be further analyzed into parts: integers into bits, strings into strings of length 1, and lists and sets into any datatype.\n\nLimitation: Beltabol does not have a tuple type, but as there is no type checking, lists can be used instead.\n\n### Basics of Integers\n\nBeltabol integers, like `0` or `42`, have the usual arithmetic operations with the usual precedence: `+`, `-`, `*`, and `/`. The last is integer division, so `5/2 == 2`.\n\nThey are also totally ordered, and have the usual set of relational operators: `<`, `<=`, `==`, `>=`, `>`, and `<>`. The relational operators produce integer `0` for false and integer `1` for true.  Nota Bene: all values, not only integers, can only be compared to values of the same type; all relational operators return 0 if given arguments of distinct types.\n\nLimitation: for the time being, only decimal literals work.\n\nLimitation: in principle, integers are multiple precision; at the current time, they are rpython ints, which wrap at a given bitwidth.\n\n### Basics of Strings\n\nBeltabol strings, like `\"foo\"` or `\"Oye, setara setara!\"` can be concatenated with the `:=:` operator, which is left associative and has precedence just below the arithmetic operators. The empty string is `\"\"` and is the identity for `:=:`.\n\nStrings are totally ordered in lexicographical order.\n\nLimitation: currently, `ord` and `chr` are defined via a lookup table in the standard prelude, so they only have the printable ASCII range.\n\nLimitation: currently there are no string escapes.\n\n### Basics of Lists\n\nBeltabol lists, like `[]` or `[0, \"wang\", []]`, are sequences of items of any beltabol type, including other lists. They can also be concatenated with `:=:`. The empty list is `[]` and is the identity for `:=:`.\n\nLists are totally ordered in lexicographical order.\n\n### Basics of Sets\n\nBeltabol sets, like `{}` or `{0, \"nada\", [], {}}` are unordered collections of elements of any beltabol type, including other sets. They can be unioned with `:=:`. The empty set is `{}` and is the identity for `:=:`.\n\nA special kind of set is the map, which has key:value pairs as elements, eg `{\"nada\":0,\"wang\":1,\"tu\":2}`. These act like functions, and when called with an existing key as an argument, return the corresponding value.\n\nSets are partially ordered in inclusion order.\n\n### Advanced Integers\n\nIntegers have a substructure of (little-endian) sequences of bits. They can be synthesized using the `<:` cons operator, whose left hand side must be a bit (0 or 1), which is shifted into the least significant place, eg: `0<:4 == 8` and `1<:4 == 5`.\n\nIntegers may also be analyzed using the `@` indexing operator, which has a higher precedence than the arithmetic operators, and picks out the bit at that place (`n@0` is the least significant bit of `n`)\n\n### Advanced Strings\n\nStrings have a substructure of sequences of length-1 strings. They can be synthesized using the `<:` cons operator, the `>:` snoc operator, and `:=:`, the splice operator. Cons prepends a length-1 string to the front of the string, snoc appends a length-1 string to the back, and splice concatenates two strings, eg: `\"b\"<:\"elta\" == \"belta\"`; `\"belt\">:\"a\" == \"belta\"`; and `\"bel\":=:\"ta\" == \"belta\"`.\n\nStrings may also be analyzed using the `@` indexing operator, which picks out the length-1 string at that place. (`\"foobar\"@1` == \"o\"`)\n\n### Advanced Lists\n\nLists have a substructure of sequences of items, of any beltabol datatype.  They can be synthesized using the `<:` cons operator, the `>:` snoc operator, and `:=:`, the splice operator, eg: `0<:[\"wang\", []] == [0,\"wang\",[]]`; `[0,\"wang\"]:>[] == [0,\"wang\",[]]`; and `[0]:=:[\"wang\",[]] == [0,\"wang\",[]]`.\n\nLists may also be analyzed using the `@` indexing operator, which picks out the item at that place. (`[0,\"wang\",[]]@2 == []`)\n\n### Advanced Sets\n\nSets have a substructure of unordered collections of elements, of any beltabol datatype. They can be synthesized using the `<:` cons operator and `:=:`, the splice operator. Because of commutativity, the `:>` snoc operator is equivalent to cons on sets. Some examples: `{0,1}:={0,2} == {0,1,2}`; `0<:{1,2} == {0,1,2} == {1,2}:>0`.\n\nSets in general may not be analyzed with the `@` indexing operator, but in the special case of maps being indexed by one of their keys, the operation evaluates to the value corresponding to that key, eg: `{\"nada\":0,\"wang\":1,\"tu\":2}@\"wang\" == 1`.\n\n## User-defined Algebraic Datatypes\n\nUser-defined algebraic datatypes have an constructor, which is an identifier, and arguments of any Beltabol datatype; eg. in `Ptr(s,n)` `Ptr` is the constructor and `s` and `n` are arguments.\n\nExample:\n```\nDa RetBelek imalowda Kuku() | Not(weting,gosh,val,richa).\n\nDa sh(n) im chu\n   \"\"                        detim n?=Kuku();\n   \"(\":=:sh(a):=:x:=:sh(b):=:\")\" detim n?=Not(\"B\",a,x,b);\n   \"<\":=:sh(a):=:x:=:sh(b):=:\">\" detim n?=Not(\"R\",a,x,b).\n```\n\nLimitation: in principle, the algebraic datatypes are totally ordered, but this is currently unimplemented.\n\n## Functions\n\nFunctions can be synthesized via composition with `,`, but they cannot be analyzed: apart from passing them to higher-order functions, the only thing to do with them is to apply them to arguments, either via the high-precedence usual syntax `f(x)`, or via the much-lower precedence `f $ x`. Examples: `(f,g)(x) == f(g(x)) == (f $ g $ x)`\n\n(More pedantically, when we say \"functions\" we are really talking about the *closures* to which they evaluate)\n\nOperators behave like two-argument functions; To use an operator as an identifier, enclose it in parens, eg `(+)`. To use an identifier as an operator, enclose it in backticks, eg `` `mod` ``.\n\n## Compound Expressions\n\nThere are two compound expressions, `chu` compounds and `fong` compounds.\n\n```\n    defn : CHU {cdecl SEMIC} cdecl\n    defn : FONG expr {rdecls SEMIC} rdecls\n```\n\nWhen compound expressions occur as subexpressions anywhere but in top-level statements, they must be fully parenthesized, eg: `2*(chu 2 detim p; 0 detim owta)`\n\n```\nDa div(n,m) im chu\n    (fong (chu [q#1, r-m] detim m<=r;\n               [q#0, r  ] detim owta)\n        wit [q,r] deting div(n,m#0)) detim m<=n;\n               [  0, n  ]            detim owta.\n```\n\n### Chu\n\n`Chu` is like Lisp's COND; each `cdecl` is of the form `expr DETIM guard` and evaluates the expression whose guard is the first to evaluate to 1.\n\nThe match operator, `?=`, which has a low precedence, may be used to extend the expression's environment. It takes a value on its left hand side, and a pattern on its right, and attempts to bind variables in the pattern in such a way as to match the value.\n\nGuards may be composed of multiple clauses, joined by the low-precedence `&&` and operator: ``(x `rep` ys) detim xs?=[x] && len(ys)==1;``\n\n### Example patterns using the `?=` match operator\n\nInteger matching: `0 detim n?=42;` or `m+mul(h,0<:m) detim n?=1<:n;`\n\nString matching: `1 detim arg?=\"-v\";` or `len(h)+len(t) detim s?=h:=:t;`\n\nList matching: `0 detim xs?=[];` or `dfs(graph, h<:seen, acc:>h, vedi(graph,h):=:t) detim vs?=h<:t;`\n\nSet matching: `0 detim xs?={};` or `dfs(graph, seen, acc, t) detim vs?=h<:t && seen?=h<:_ ;`\n\nNote that the clauses of a `chu` expression are always of the form `expression detim guard`.\n\n### Fong\n\n`Fong` is a bit like Lisp's LET; each `rdecl` is of the form `WIT binding DETING expr` where `binding` is bound to the value of `expr`.\n\nWhen there are multiple bindings, each `expr` can see the bindings which come below (after) it.\n\n```\nDu chek (fong cclvi*cclvi\n  wit cclvi deting xvi*xvi;\n  wit xvi   deting iv*iv;\n  wit iv    deting ii*ii;\n  wit ii    deting 2)\nim 65536.\n```\n\nTo define functions, `binding` should be of the form `id(arguments...)`, as in the definition of `nawit(y,xs)` following:\n\n```\nDa nub(xs) im fong (chu\n    h<:nub(nawit(h,t)) detim xs?=h<:t;\n    []                 detim owta)\n    wit nawit(y,xs) deting (chu\n        (chu  nawit(y,t) detim h==y;\n           h<:nawit(y,t) detim owta) detim xs?=h<:t;\n         []                          detim owta).\n```\n\nIn general, what in another language might be written as `let y=z in let v=w in x` would be expressed in Beltabol as `(fong x wit v deting w; wit y deting z)`. Note the change in order!\n\n### Fong/delowda for list comprehensions\n\nUsing `delowda` instead of `deting` turns a `fong` compound expression into a list comprehension.\n\n```\nDa flatten(xss) im fong x\n    wit x  delowda xs;\n    wit xs delowda xss.\n\nDu chek flatten([[0],[],[1,2]]) == [0,1,2].\n```\n\nIn general, what in another language might be written as `[x | y<-z, v<-w]` would be expressed in Beltabol as `(fong x wit v delowda w; wit y delowda z)`. Note the change in order! To produce the effect of a guard, either use a `delowda` clause which evaluates to either a length-0 list for failure or length-1 list for success, or use a refutable pattern in the binding position of the `WIT binding DELOWDA expression` clause.\n\nNote that one can mix `deting` and `delowda` clauses within a single `fong`; the delowdas will act to multiply results but the detings always introduce a single binding (per the delowda's underneath them) only. As is usual with the list monad, a fong comprehension expression produces a flattened list of results, no matter how many delowda clauses it has.\n\n```\nDu chek (fong z\n  wit z deting 2*y;\n  wit y delowda [x+1,x-1];\n  wit x delowda [z+1,z+2];\n  wit z deting 0) im [4,0,6,2].\n```\n\n### Fong/unte for mutual recursion\n\nUse `unte` between `wit` definitions for mutual recursion:\n```\n(fong even(4)\n  wit even(n) deting (chu 1        detim n==0;\n                          odd(n-1) detim owta)\n  unte\n  wit odd(n) deting (chu 0         detim n==0;\n                         even(n-1) detim owta)).\n```\n\n### Fong/imalowda for local algebraic types\n\n```\n(fong dubik(\"\",eg) == gut\n  wit eg         deting [Lit(\"a\"),Ptr(0,5),Lit(\"b\"),Ptr(4,6)];\n  wit gut        deting \"aaaaaabaabaab\";\n  wit dubik(a,c) deting (chu\n        dubik(a<:v  ,              t) detim c?=Lit(v)  <:t;\n        dubik(a     ,              t) detim c?=Ptr(s,0)<:t;\n        dubik(a<:a@s,Ptr(s+1,n-1)<:t) detim c?=Ptr(s,n)<:t;\n              a                       detim owta);\n  wit Mali       imalowda Lit(v) | Ptr(s,l))\n\n```\n\n### Important! Fong Expression Evaluation Order \nIn Beltabol, `fong` expressions (similar to let expressions in other languages) have a unique evaluation order that's opposite to their visual presentation order. \n\n*Key Rule:* bindings in a `fong` expression are evaluated *from bottom to top*, not top to bottom as might be expected from reading order. \n\n```\nDa lookup(table, key) im \n    fong find_in_bucket(bucket, key) // Evaluated Last\n    wit bucket deting table@index; // Evaluated Next\n    wit index deting hash(key). // Evaluated First\n```\n\nThis is to give a top-down overview of the code: emphasizing the forest, not the trees.\n\n## Statements\n\nThere are four statements:\n```\n    statement : DA expr IM defn DOT      \n    statement : DA expr IMALOWDA expr DOT \n    statement : DU CHEK expr IM expr DOT  \n    statement : SHOWXA defn DOT           \n```\n\n1. `Da ... im ...` binds definitions (at the top level)\n2. `Da ... imalowda ...` creates algebraic datatypes\n3. `Du chek ... im ...` is an equality test (run with `--test` option)\n4. `Showxa ...` is used for print debugging\n\nLimitation: Beltabol currently has no I/O; if streams are ever implemented, then probably `Mesach ...` will provide bytestream output)\n\n```\nDa four im 2+2.\nDa peano imalowda Zero | Succ(n).\nDu chek four im 4.\nShowxa Succ(Succ(Zero)).\n```\n\nNote that compound expressions need not be parenthesized when occuring as `defn`s in the `Da/im` and `Showxa` statements, eg:\n\n```\nDa fak(n) im chu\n    n*fak(n-1) detim 1<=n;\n    1          detim owta.\n```\n\nHowever, statements *always* end with `.`.\n\n## Comments\n\nLine comments go from an opening `//` to the end of line.\n\n## Standard prelude\n\n|name|purpose|\n|----|-------|\n|owta| 1 (True)|\n|max(x,y)|**max**imum of **x** and **y**|\n|mebi(f)|returns fn returning x if f(x) fails, otherwise f(x)|\n|walowda(f)|returns fn returning the least fixpoint of **f**(**f**(...**f**(x)...))|\n|sqrt(n)|integer square root of **n**||\n|mod(i,j)|i **mod** j|\n|len(v)|length of **v**alue|\n|chr(n)|length-1 string with numeric value **n**||\n|ord(c)|numeric value of length-1 string **c**|\n|unit(v)|returns empty string or list as **v** is string or list||\n|(**)(b,e)|raises int **b**ase to **e**xponent|\n\n## See also\n\nSee the [other docs](bb.md) and the [brief introduction](https://drive.google.com/file/d/1zTGjy9KeW4cqagXHlVDwKmcZ1mEz6u-K/view).\n",
      "task": "Please write an insertion sort.\nPlease use `Du chek` to check your program",
      "program": "Da insert(x, xs) im chu\n    [x]                     detim xs == [];\n    (chu x<:xs      detim x <= (xs@0);\n         (xs@0)<:insert(x, chu t detim xs?=h<:t; [] detim owta) detim owta).\n\nDa isort(xs) im chu\n    []              detim xs == [];\n    insert(xs@0, isort(chu t detim xs?=h<:t; [] detim owta)) detim owta.\n\nDu chek isort([3,1,4,1,5,9,2,6,5,3,5]) im [1,1,2,3,3,4,5,5,5,6,9]."
    },
    {
      "augmented": true,
      "target": "You are a coding agent that programs in Beltabol, a novel programming language. The documentation follows:\n# Da Beltabol fong but fo gova\n\nThis file is a bottom-up introduction to Beltabol, a novel eager functional language.\n\n## Built-in Datatypes and simple Expressions\n\nBeltabol currently has four built-in datatypes: integers, strings, lists, and sets. All can be treated in a basic fashion, operating upon each value as a whole, or (in an advanced fashion) can be further analyzed into parts: integers into bits, strings into strings of length 1, and lists and sets into any datatype.\n\nLimitation: Beltabol does not have a tuple type, but as there is no type checking, lists can be used instead.\n\n### Basics of Integers\n\nBeltabol integers, like `0` or `42`, have the usual arithmetic operations with the usual precedence: `+`, `-`, `*`, and `/`. The last is integer division, so `5/2 == 2`.\n\nThey are also totally ordered, and have the usual set of relational operators: `<`, `<=`, `==`, `>=`, `>`, and `<>`. The relational operators produce integer `0` for false and integer `1` for true.  Nota Bene: all values, not only integers, can only be compared to values of the same type; all relational operators return 0 if given arguments of distinct types.\n\nLimitation: for the time being, only decimal literals work.\n\nLimitation: in principle, integers are multiple precision; at the current time, they are rpython ints, which wrap at a given bitwidth.\n\n### Basics of Strings\n\nBeltabol strings, like `\"foo\"` or `\"Oye, setara setara!\"` can be concatenated with the `:=:` operator, which is left associative and has precedence just below the arithmetic operators. The empty string is `\"\"` and is the identity for `:=:`.\n\nStrings are totally ordered in lexicographical order.\n\nLimitation: currently, `ord` and `chr` are defined via a lookup table in the standard prelude, so they only have the printable ASCII range.\n\nLimitation: currently there are no string escapes.\n\n### Basics of Lists\n\nBeltabol lists, like `[]` or `[0, \"wang\", []]`, are sequences of items of any beltabol type, including other lists. They can also be concatenated with `:=:`. The empty list is `[]` and is the identity for `:=:`.\n\nLists are totally ordered in lexicographical order.\n\n### Basics of Sets\n\nBeltabol sets, like `{}` or `{0, \"nada\", [], {}}` are unordered collections of elements of any beltabol type, including other sets. They can be unioned with `:=:`. The empty set is `{}` and is the identity for `:=:`.\n\nA special kind of set is the map, which has key:value pairs as elements, eg `{\"nada\":0,\"wang\":1,\"tu\":2}`. These act like functions, and when called with an existing key as an argument, return the corresponding value.\n\nSets are partially ordered in inclusion order.\n\n### Advanced Integers\n\nIntegers have a substructure of (little-endian) sequences of bits. They can be synthesized using the `<:` cons operator, whose left hand side must be a bit (0 or 1), which is shifted into the least significant place, eg: `0<:4 == 8` and `1<:4 == 5`.\n\nIntegers may also be analyzed using the `@` indexing operator, which has a higher precedence than the arithmetic operators, and picks out the bit at that place (`n@0` is the least significant bit of `n`)\n\n### Advanced Strings\n\nStrings have a substructure of sequences of length-1 strings. They can be synthesized using the `<:` cons operator, the `>:` snoc operator, and `:=:`, the splice operator. Cons prepends a length-1 string to the front of the string, snoc appends a length-1 string to the back, and splice concatenates two strings, eg: `\"b\"<:\"elta\" == \"belta\"`; `\"belt\">:\"a\" == \"belta\"`; and `\"bel\":=:\"ta\" == \"belta\"`.\n\nStrings may also be analyzed using the `@` indexing operator, which picks out the length-1 string at that place. (`\"foobar\"@1` == \"o\"`)\n\n### Advanced Lists\n\nLists have a substructure of sequences of items, of any beltabol datatype.  They can be synthesized using the `<:` cons operator, the `>:` snoc operator, and `:=:`, the splice operator, eg: `0<:[\"wang\", []] == [0,\"wang\",[]]`; `[0,\"wang\"]:>[] == [0,\"wang\",[]]`; and `[0]:=:[\"wang\",[]] == [0,\"wang\",[]]`.\n\nLists may also be analyzed using the `@` indexing operator, which picks out the item at that place. (`[0,\"wang\",[]]@2 == []`)\n\n### Advanced Sets\n\nSets have a substructure of unordered collections of elements, of any beltabol datatype. They can be synthesized using the `<:` cons operator and `:=:`, the splice operator. Because of commutativity, the `:>` snoc operator is equivalent to cons on sets. Some examples: `{0,1}:={0,2} == {0,1,2}`; `0<:{1,2} == {0,1,2} == {1,2}:>0`.\n\nSets in general may not be analyzed with the `@` indexing operator, but in the special case of maps being indexed by one of their keys, the operation evaluates to the value corresponding to that key, eg: `{\"nada\":0,\"wang\":1,\"tu\":2}@\"wang\" == 1`.\n\n## User-defined Algebraic Datatypes\n\nUser-defined algebraic datatypes have an constructor, which is an identifier, and arguments of any Beltabol datatype; eg. in `Ptr(s,n)` `Ptr` is the constructor and `s` and `n` are arguments.\n\nExample:\n```\nDa RetBelek imalowda Kuku() | Not(weting,gosh,val,richa).\n\nDa sh(n) im chu\n   \"\"                        detim n?=Kuku();\n   \"(\":=:sh(a):=:x:=:sh(b):=:\")\" detim n?=Not(\"B\",a,x,b);\n   \"<\":=:sh(a):=:x:=:sh(b):=:\">\" detim n?=Not(\"R\",a,x,b).\n```\n\nLimitation: in principle, the algebraic datatypes are totally ordered, but this is currently unimplemented.\n\n## Functions\n\nFunctions can be synthesized via composition with `,`, but they cannot be analyzed: apart from passing them to higher-order functions, the only thing to do with them is to apply them to arguments, either via the high-precedence usual syntax `f(x)`, or via the much-lower precedence `f $ x`. Examples: `(f,g)(x) == f(g(x)) == (f $ g $ x)`\n\n(More pedantically, when we say \"functions\" we are really talking about the *closures* to which they evaluate)\n\nOperators behave like two-argument functions; To use an operator as an identifier, enclose it in parens, eg `(+)`. To use an identifier as an operator, enclose it in backticks, eg `` `mod` ``.\n\n## Compound Expressions\n\nThere are two compound expressions, `chu` compounds and `fong` compounds.\n\n```\n    defn : CHU {cdecl SEMIC} cdecl\n    defn : FONG expr {rdecls SEMIC} rdecls\n```\n\nWhen compound expressions occur as subexpressions anywhere but in top-level statements, they must be fully parenthesized, eg: `2*(chu 2 detim p; 0 detim owta)`\n\n```\nDa div(n,m) im chu\n    (fong (chu [q#1, r-m] detim m<=r;\n               [q#0, r  ] detim owta)\n        wit [q,r] deting div(n,m#0)) detim m<=n;\n               [  0, n  ]            detim owta.\n```\n\n### Chu\n\n`Chu` is like Lisp's COND; each `cdecl` is of the form `expr DETIM guard` and evaluates the expression whose guard is the first to evaluate to 1.\n\nThe match operator, `?=`, which has a low precedence, may be used to extend the expression's environment. It takes a value on its left hand side, and a pattern on its right, and attempts to bind variables in the pattern in such a way as to match the value.\n\nGuards may be composed of multiple clauses, joined by the low-precedence `&&` and operator: ``(x `rep` ys) detim xs?=[x] && len(ys)==1;``\n\n### Example patterns using the `?=` match operator\n\nInteger matching: `0 detim n?=42;` or `m+mul(h,0<:m) detim n?=1<:n;`\n\nString matching: `1 detim arg?=\"-v\";` or `len(h)+len(t) detim s?=h:=:t;`\n\nList matching: `0 detim xs?=[];` or `dfs(graph, h<:seen, acc:>h, vedi(graph,h):=:t) detim vs?=h<:t;`\n\nSet matching: `0 detim xs?={};` or `dfs(graph, seen, acc, t) detim vs?=h<:t && seen?=h<:_ ;`\n\nNote that the clauses of a `chu` expression are always of the form `expression detim guard`.\n\n### Fong\n\n`Fong` is a bit like Lisp's LET; each `rdecl` is of the form `WIT binding DETING expr` where `binding` is bound to the value of `expr`.\n\nWhen there are multiple bindings, each `expr` can see the bindings which come below (after) it.\n\n```\nDu chek (fong cclvi*cclvi\n  wit cclvi deting xvi*xvi;\n  wit xvi   deting iv*iv;\n  wit iv    deting ii*ii;\n  wit ii    deting 2)\nim 65536.\n```\n\nTo define functions, `binding` should be of the form `id(arguments...)`, as in the definition of `nawit(y,xs)` following:\n\n```\nDa nub(xs) im fong (chu\n    h<:nub(nawit(h,t)) detim xs?=h<:t;\n    []                 detim owta)\n    wit nawit(y,xs) deting (chu\n        (chu  nawit(y,t) detim h==y;\n           h<:nawit(y,t) detim owta) detim xs?=h<:t;\n         []                          detim owta).\n```\n\nIn general, what in another language might be written as `let y=z in let v=w in x` would be expressed in Beltabol as `(fong x wit v deting w; wit y deting z)`. Note the change in order!\n\n### Fong/delowda for list comprehensions\n\nUsing `delowda` instead of `deting` turns a `fong` compound expression into a list comprehension.\n\n```\nDa flatten(xss) im fong x\n    wit x  delowda xs;\n    wit xs delowda xss.\n\nDu chek flatten([[0],[],[1,2]]) == [0,1,2].\n```\n\nIn general, what in another language might be written as `[x | y<-z, v<-w]` would be expressed in Beltabol as `(fong x wit v delowda w; wit y delowda z)`. Note the change in order! To produce the effect of a guard, either use a `delowda` clause which evaluates to either a length-0 list for failure or length-1 list for success, or use a refutable pattern in the binding position of the `WIT binding DELOWDA expression` clause.\n\nNote that one can mix `deting` and `delowda` clauses within a single `fong`; the delowdas will act to multiply results but the detings always introduce a single binding (per the delowda's underneath them) only. As is usual with the list monad, a fong comprehension expression produces a flattened list of results, no matter how many delowda clauses it has.\n\n```\nDu chek (fong z\n  wit z deting 2*y;\n  wit y delowda [x+1,x-1];\n  wit x delowda [z+1,z+2];\n  wit z deting 0) im [4,0,6,2].\n```\n\n### Fong/unte for mutual recursion\n\nUse `unte` between `wit` definitions for mutual recursion:\n```\n(fong even(4)\n  wit even(n) deting (chu 1        detim n==0;\n                          odd(n-1) detim owta)\n  unte\n  wit odd(n) deting (chu 0         detim n==0;\n                         even(n-1) detim owta)).\n```\n\n### Fong/imalowda for local algebraic types\n\n```\n(fong dubik(\"\",eg) == gut\n  wit eg         deting [Lit(\"a\"),Ptr(0,5),Lit(\"b\"),Ptr(4,6)];\n  wit gut        deting \"aaaaaabaabaab\";\n  wit dubik(a,c) deting (chu\n        dubik(a<:v  ,              t) detim c?=Lit(v)  <:t;\n        dubik(a     ,              t) detim c?=Ptr(s,0)<:t;\n        dubik(a<:a@s,Ptr(s+1,n-1)<:t) detim c?=Ptr(s,n)<:t;\n              a                       detim owta);\n  wit Mali       imalowda Lit(v) | Ptr(s,l))\n\n```\n\n### Important! Fong Expression Evaluation Order \nIn Beltabol, `fong` expressions (similar to let expressions in other languages) have a unique evaluation order that's opposite to their visual presentation order. \n\n*Key Rule:* bindings in a `fong` expression are evaluated *from bottom to top*, not top to bottom as might be expected from reading order. \n\n```\nDa lookup(table, key) im \n    fong find_in_bucket(bucket, key) // Evaluated Last\n    wit bucket deting table@index; // Evaluated Next\n    wit index deting hash(key). // Evaluated First\n```\n\nThis is to give a top-down overview of the code: emphasizing the forest, not the trees.\n\n## Statements\n\nThere are four statements:\n```\n    statement : DA expr IM defn DOT      \n    statement : DA expr IMALOWDA expr DOT \n    statement : DU CHEK expr IM expr DOT  \n    statement : SHOWXA defn DOT           \n```\n\n1. `Da ... im ...` binds definitions (at the top level)\n2. `Da ... imalowda ...` creates algebraic datatypes\n3. `Du chek ... im ...` is an equality test (run with `--test` option)\n4. `Showxa ...` is used for print debugging\n\nLimitation: Beltabol currently has no I/O; if streams are ever implemented, then probably `Mesach ...` will provide bytestream output)\n\n```\nDa four im 2+2.\nDa peano imalowda Zero | Succ(n).\nDu chek four im 4.\nShowxa Succ(Succ(Zero)).\n```\n\nNote that compound expressions need not be parenthesized when occuring as `defn`s in the `Da/im` and `Showxa` statements, eg:\n\n```\nDa fak(n) im chu\n    n*fak(n-1) detim 1<=n;\n    1          detim owta.\n```\n\nHowever, statements *always* end with `.`.\n\n## Comments\n\nLine comments go from an opening `//` to the end of line.\n\n## Standard prelude\n\n|name|purpose|\n|----|-------|\n|owta| 1 (True)|\n|max(x,y)|**max**imum of **x** and **y**|\n|mebi(f)|returns fn returning x if f(x) fails, otherwise f(x)|\n|walowda(f)|returns fn returning the least fixpoint of **f**(**f**(...**f**(x)...))|\n|sqrt(n)|integer square root of **n**||\n|mod(i,j)|i **mod** j|\n|len(v)|length of **v**alue|\n|chr(n)|length-1 string with numeric value **n**||\n|ord(c)|numeric value of length-1 string **c**|\n|unit(v)|returns empty string or list as **v** is string or list||\n|(**)(b,e)|raises int **b**ase to **e**xponent|\n\n## See also\n\nSee the [other docs](bb.md) and the [brief introduction](https://drive.google.com/file/d/1zTGjy9KeW4cqagXHlVDwKmcZ1mEz6u-K/view).\n",
      "task": "Please write a merge sort.\nPlease use `Du chek` to check your program",
      "program": "Da merge(xs,ys) im fong (chu\n    xs                                detim ys==[];\n    ys                                detim xs==[];\n    (chu x<:merge(xs,y<:ys) detim x<=y;\n         y<:merge(x<:xs,ys) detim owta) detim xs?=x<:xs && ys?=y<:ys;\n    [] detim owta)\n  wit xs deting xs;\n  wit ys deting ys.\n\nDa mergesort(xs) im fong (chu\n    []                    detim len(xs)==0;\n    [x]                   detim len(xs)==1;\n    merge(mergesort(l),mergesort(r)) detim len(xs)>1 && xs?=l:=:r)\n  wit xs deting xs.\n  \nDu chek mergesort([]) im [].\nDu chek mergesort([42]) im [42].\nDu chek mergesort([3,1,4,1,5,9,2,6,5,3,5]) im [1,1,2,3,3,4,5,5,5,6,9]."
    },
    {
      "target": "You are a coding agent that programs in Beltabol, a novel programming language. The documentation follows:\n# Da Beltabol fong but fo gova\n\nThis file is a bottom-up introduction to Beltabol, a novel eager functional language.\n\n## Built-in Datatypes and simple Expressions\n\nBeltabol currently has four built-in datatypes: integers, strings, lists, and sets. All can be treated in a basic fashion, operating upon each value as a whole, or (in an advanced fashion) can be further analyzed into parts: integers into bits, strings into strings of length 1, and lists and sets into any datatype.\n\nLimitation: Beltabol does not have a tuple type, but as there is no type checking, lists can be used instead.\n\n### Basics of Integers\n\nBeltabol integers, like `0` or `42`, have the usual arithmetic operations with the usual precedence: `+`, `-`, `*`, and `/`. The last is integer division, so `5/2 == 2`.\n\nThey are also totally ordered, and have the usual set of relational operators: `<`, `<=`, `==`, `>=`, `>`, and `<>`. The relational operators produce integer `0` for false and integer `1` for true.  Nota Bene: all values, not only integers, can only be compared to values of the same type; all relational operators return 0 if given arguments of distinct types.\n\nLimitation: for the time being, only decimal literals work.\n\nLimitation: in principle, integers are multiple precision; at the current time, they are rpython ints, which wrap at a given bitwidth.\n\n### Basics of Strings\n\nBeltabol strings, like `\"foo\"` or `\"Oye, setara setara!\"` can be concatenated with the `:=:` operator, which is left associative and has precedence just below the arithmetic operators. The empty string is `\"\"` and is the identity for `:=:`.\n\nStrings are totally ordered in lexicographical order.\n\nLimitation: currently, `ord` and `chr` are defined via a lookup table in the standard prelude, so they only have the printable ASCII range.\n\nLimitation: currently there are no string escapes.\n\n### Basics of Lists\n\nBeltabol lists, like `[]` or `[0, \"wang\", []]`, are sequences of items of any beltabol type, including other lists. They can also be concatenated with `:=:`. The empty list is `[]` and is the identity for `:=:`.\n\nLists are totally ordered in lexicographical order.\n\n### Basics of Sets\n\nBeltabol sets, like `{}` or `{0, \"nada\", [], {}}` are unordered collections of elements of any beltabol type, including other sets. They can be unioned with `:=:`. The empty set is `{}` and is the identity for `:=:`.\n\nA special kind of set is the map, which has key:value pairs as elements, eg `{\"nada\":0,\"wang\":1,\"tu\":2}`. These act like functions, and when called with an existing key as an argument, return the corresponding value.\n\nSets are partially ordered in inclusion order.\n\n### Advanced Integers\n\nIntegers have a substructure of (little-endian) sequences of bits. They can be synthesized using the `<:` cons operator, whose left hand side must be a bit (0 or 1), which is shifted into the least significant place, eg: `0<:4 == 8` and `1<:4 == 5`.\n\nIntegers may also be analyzed using the `@` indexing operator, which has a higher precedence than the arithmetic operators, and picks out the bit at that place (`n@0` is the least significant bit of `n`)\n\n### Advanced Strings\n\nStrings have a substructure of sequences of length-1 strings. They can be synthesized using the `<:` cons operator, the `>:` snoc operator, and `:=:`, the splice operator. Cons prepends a length-1 string to the front of the string, snoc appends a length-1 string to the back, and splice concatenates two strings, eg: `\"b\"<:\"elta\" == \"belta\"`; `\"belt\">:\"a\" == \"belta\"`; and `\"bel\":=:\"ta\" == \"belta\"`.\n\nStrings may also be analyzed using the `@` indexing operator, which picks out the length-1 string at that place. (`\"foobar\"@1` == \"o\"`)\n\n### Advanced Lists\n\nLists have a substructure of sequences of items, of any beltabol datatype.  They can be synthesized using the `<:` cons operator, the `>:` snoc operator, and `:=:`, the splice operator, eg: `0<:[\"wang\", []] == [0,\"wang\",[]]`; `[0,\"wang\"]:>[] == [0,\"wang\",[]]`; and `[0]:=:[\"wang\",[]] == [0,\"wang\",[]]`.\n\nLists may also be analyzed using the `@` indexing operator, which picks out the item at that place. (`[0,\"wang\",[]]@2 == []`)\n\n### Advanced Sets\n\nSets have a substructure of unordered collections of elements, of any beltabol datatype. They can be synthesized using the `<:` cons operator and `:=:`, the splice operator. Because of commutativity, the `:>` snoc operator is equivalent to cons on sets. Some examples: `{0,1}:={0,2} == {0,1,2}`; `0<:{1,2} == {0,1,2} == {1,2}:>0`.\n\nSets in general may not be analyzed with the `@` indexing operator, but in the special case of maps being indexed by one of their keys, the operation evaluates to the value corresponding to that key, eg: `{\"nada\":0,\"wang\":1,\"tu\":2}@\"wang\" == 1`.\n\n## User-defined Algebraic Datatypes\n\nUser-defined algebraic datatypes have an constructor, which is an identifier, and arguments of any Beltabol datatype; eg. in `Ptr(s,n)` `Ptr` is the constructor and `s` and `n` are arguments.\n\nExample:\n```\nDa RetBelek imalowda Kuku() | Not(weting,gosh,val,richa).\n\nDa sh(n) im chu\n   \"\"                        detim n?=Kuku();\n   \"(\":=:sh(a):=:x:=:sh(b):=:\")\" detim n?=Not(\"B\",a,x,b);\n   \"<\":=:sh(a):=:x:=:sh(b):=:\">\" detim n?=Not(\"R\",a,x,b).\n```\n\nLimitation: in principle, the algebraic datatypes are totally ordered, but this is currently unimplemented.\n\n## Functions\n\nFunctions can be synthesized via composition with `,`, but they cannot be analyzed: apart from passing them to higher-order functions, the only thing to do with them is to apply them to arguments, either via the high-precedence usual syntax `f(x)`, or via the much-lower precedence `f $ x`. Examples: `(f,g)(x) == f(g(x)) == (f $ g $ x)`\n\n(More pedantically, when we say \"functions\" we are really talking about the *closures* to which they evaluate)\n\nOperators behave like two-argument functions; To use an operator as an identifier, enclose it in parens, eg `(+)`. To use an identifier as an operator, enclose it in backticks, eg `` `mod` ``.\n\n## Compound Expressions\n\nThere are two compound expressions, `chu` compounds and `fong` compounds.\n\n```\n    defn : CHU {cdecl SEMIC} cdecl\n    defn : FONG expr {rdecls SEMIC} rdecls\n```\n\nWhen compound expressions occur as subexpressions anywhere but in top-level statements, they must be fully parenthesized, eg: `2*(chu 2 detim p; 0 detim owta)`\n\n```\nDa div(n,m) im chu\n    (fong (chu [q#1, r-m] detim m<=r;\n               [q#0, r  ] detim owta)\n        wit [q,r] deting div(n,m#0)) detim m<=n;\n               [  0, n  ]            detim owta.\n```\n\n### Chu\n\n`Chu` is like Lisp's COND; each `cdecl` is of the form `expr DETIM guard` and evaluates the expression whose guard is the first to evaluate to 1.\n\nThe match operator, `?=`, which has a low precedence, may be used to extend the expression's environment. It takes a value on its left hand side, and a pattern on its right, and attempts to bind variables in the pattern in such a way as to match the value.\n\nGuards may be composed of multiple clauses, joined by the low-precedence `&&` and operator: ``(x `rep` ys) detim xs?=[x] && len(ys)==1;``\n\n### Example patterns using the `?=` match operator\n\nInteger matching: `0 detim n?=42;` or `m+mul(h,0<:m) detim n?=1<:n;`\n\nString matching: `1 detim arg?=\"-v\";` or `len(h)+len(t) detim s?=h:=:t;`\n\nList matching: `0 detim xs?=[];` or `dfs(graph, h<:seen, acc:>h, vedi(graph,h):=:t) detim vs?=h<:t;`\n\nSet matching: `0 detim xs?={};` or `dfs(graph, seen, acc, t) detim vs?=h<:t && seen?=h<:_ ;`\n\nNote that the clauses of a `chu` expression are always of the form `expression detim guard`.\n\n### Fong\n\n`Fong` is a bit like Lisp's LET; each `rdecl` is of the form `WIT binding DETING expr` where `binding` is bound to the value of `expr`.\n\nWhen there are multiple bindings, each `expr` can see the bindings which come below (after) it.\n\n```\nDu chek (fong cclvi*cclvi\n  wit cclvi deting xvi*xvi;\n  wit xvi   deting iv*iv;\n  wit iv    deting ii*ii;\n  wit ii    deting 2)\nim 65536.\n```\n\nTo define functions, `binding` should be of the form `id(arguments...)`, as in the definition of `nawit(y,xs)` following:\n\n```\nDa nub(xs) im fong (chu\n    h<:nub(nawit(h,t)) detim xs?=h<:t;\n    []                 detim owta)\n    wit nawit(y,xs) deting (chu\n        (chu  nawit(y,t) detim h==y;\n           h<:nawit(y,t) detim owta) detim xs?=h<:t;\n         []                          detim owta).\n```\n\nIn general, what in another language might be written as `let y=z in let v=w in x` would be expressed in Beltabol as `(fong x wit v deting w; wit y deting z)`. Note the change in order!\n\n### Fong/delowda for list comprehensions\n\nUsing `delowda` instead of `deting` turns a `fong` compound expression into a list comprehension.\n\n```\nDa flatten(xss) im fong x\n    wit x  delowda xs;\n    wit xs delowda xss.\n\nDu chek flatten([[0],[],[1,2]]) == [0,1,2].\n```\n\nIn general, what in another language might be written as `[x | y<-z, v<-w]` would be expressed in Beltabol as `(fong x wit v delowda w; wit y delowda z)`. Note the change in order! To produce the effect of a guard, either use a `delowda` clause which evaluates to either a length-0 list for failure or length-1 list for success, or use a refutable pattern in the binding position of the `WIT binding DELOWDA expression` clause.\n\nNote that one can mix `deting` and `delowda` clauses within a single `fong`; the delowdas will act to multiply results but the detings always introduce a single binding (per the delowda's underneath them) only. As is usual with the list monad, a fong comprehension expression produces a flattened list of results, no matter how many delowda clauses it has.\n\n```\nDu chek (fong z\n  wit z deting 2*y;\n  wit y delowda [x+1,x-1];\n  wit x delowda [z+1,z+2];\n  wit z deting 0) im [4,0,6,2].\n```\n\n### Fong/unte for mutual recursion\n\nUse `unte` between `wit` definitions for mutual recursion:\n```\n(fong even(4)\n  wit even(n) deting (chu 1        detim n==0;\n                          odd(n-1) detim owta)\n  unte\n  wit odd(n) deting (chu 0         detim n==0;\n                         even(n-1) detim owta)).\n```\n\n### Fong/imalowda for local algebraic types\n\n```\n(fong dubik(\"\",eg) == gut\n  wit eg         deting [Lit(\"a\"),Ptr(0,5),Lit(\"b\"),Ptr(4,6)];\n  wit gut        deting \"aaaaaabaabaab\";\n  wit dubik(a,c) deting (chu\n        dubik(a<:v  ,              t) detim c?=Lit(v)  <:t;\n        dubik(a     ,              t) detim c?=Ptr(s,0)<:t;\n        dubik(a<:a@s,Ptr(s+1,n-1)<:t) detim c?=Ptr(s,n)<:t;\n              a                       detim owta);\n  wit Mali       imalowda Lit(v) | Ptr(s,l))\n\n```\n\n### Important! Fong Expression Evaluation Order \nIn Beltabol, `fong` expressions (similar to let expressions in other languages) have a unique evaluation order that's opposite to their visual presentation order. \n\n*Key Rule:* bindings in a `fong` expression are evaluated *from bottom to top*, not top to bottom as might be expected from reading order. \n\n```\nDa lookup(table, key) im \n    fong find_in_bucket(bucket, key) // Evaluated Last\n    wit bucket deting table@index; // Evaluated Next\n    wit index deting hash(key). // Evaluated First\n```\n\nThis is to give a top-down overview of the code: emphasizing the forest, not the trees.\n\n## Statements\n\nThere are four statements:\n```\n    statement : DA expr IM defn DOT      \n    statement : DA expr IMALOWDA expr DOT \n    statement : DU CHEK expr IM expr DOT  \n    statement : SHOWXA defn DOT           \n```\n\n1. `Da ... im ...` binds definitions (at the top level)\n2. `Da ... imalowda ...` creates algebraic datatypes\n3. `Du chek ... im ...` is an equality test (run with `--test` option)\n4. `Showxa ...` is used for print debugging\n\nLimitation: Beltabol currently has no I/O; if streams are ever implemented, then probably `Mesach ...` will provide bytestream output)\n\n```\nDa four im 2+2.\nDa peano imalowda Zero | Succ(n).\nDu chek four im 4.\nShowxa Succ(Succ(Zero)).\n```\n\nNote that compound expressions need not be parenthesized when occuring as `defn`s in the `Da/im` and `Showxa` statements, eg:\n\n```\nDa fak(n) im chu\n    n*fak(n-1) detim 1<=n;\n    1          detim owta.\n```\n\nHowever, statements *always* end with `.`.\n\n## Comments\n\nLine comments go from an opening `//` to the end of line.\n\n## Standard prelude\n\n|name|purpose|\n|----|-------|\n|owta| 1 (True)|\n|max(x,y)|**max**imum of **x** and **y**|\n|mebi(f)|returns fn returning x if f(x) fails, otherwise f(x)|\n|walowda(f)|returns fn returning the least fixpoint of **f**(**f**(...**f**(x)...))|\n|sqrt(n)|integer square root of **n**||\n|mod(i,j)|i **mod** j|\n|len(v)|length of **v**alue|\n|chr(n)|length-1 string with numeric value **n**||\n|ord(c)|numeric value of length-1 string **c**|\n|unit(v)|returns empty string or list as **v** is string or list||\n|(**)(b,e)|raises int **b**ase to **e**xponent|\n\n## See also\n\nSee the [other docs](bb.md) and the [brief introduction](https://drive.google.com/file/d/1zTGjy9KeW4cqagXHlVDwKmcZ1mEz6u-K/view).\n",
      "task": "Please write Tarjan's algorithm.\nPlease use `Du chek` to check your program",
      "program": ""
    },
    {
      "target": "You are a coding agent that programs in Beltabol, a novel programming language. The documentation follows:\n# Da Beltabol fong but fo gova\n\nThis file is a bottom-up introduction to Beltabol, a novel eager functional language.\n\n## Built-in Datatypes and simple Expressions\n\nBeltabol currently has four built-in datatypes: integers, strings, lists, and sets. All can be treated in a basic fashion, operating upon each value as a whole, or (in an advanced fashion) can be further analyzed into parts: integers into bits, strings into strings of length 1, and lists and sets into any datatype.\n\nLimitation: Beltabol does not have a tuple type, but as there is no type checking, lists can be used instead.\n\n### Basics of Integers\n\nBeltabol integers, like `0` or `42`, have the usual arithmetic operations with the usual precedence: `+`, `-`, `*`, and `/`. The last is integer division, so `5/2 == 2`.\n\nThey are also totally ordered, and have the usual set of relational operators: `<`, `<=`, `==`, `>=`, `>`, and `<>`. The relational operators produce integer `0` for false and integer `1` for true.  Nota Bene: all values, not only integers, can only be compared to values of the same type; all relational operators return 0 if given arguments of distinct types.\n\nLimitation: for the time being, only decimal literals work.\n\nLimitation: in principle, integers are multiple precision; at the current time, they are rpython ints, which wrap at a given bitwidth.\n\n### Basics of Strings\n\nBeltabol strings, like `\"foo\"` or `\"Oye, setara setara!\"` can be concatenated with the `:=:` operator, which is left associative and has precedence just below the arithmetic operators. The empty string is `\"\"` and is the identity for `:=:`.\n\nStrings are totally ordered in lexicographical order.\n\nLimitation: currently, `ord` and `chr` are defined via a lookup table in the standard prelude, so they only have the printable ASCII range.\n\nLimitation: currently there are no string escapes.\n\n### Basics of Lists\n\nBeltabol lists, like `[]` or `[0, \"wang\", []]`, are sequences of items of any beltabol type, including other lists. They can also be concatenated with `:=:`. The empty list is `[]` and is the identity for `:=:`.\n\nLists are totally ordered in lexicographical order.\n\n### Basics of Sets\n\nBeltabol sets, like `{}` or `{0, \"nada\", [], {}}` are unordered collections of elements of any beltabol type, including other sets. They can be unioned with `:=:`. The empty set is `{}` and is the identity for `:=:`.\n\nA special kind of set is the map, which has key:value pairs as elements, eg `{\"nada\":0,\"wang\":1,\"tu\":2}`. These act like functions, and when called with an existing key as an argument, return the corresponding value.\n\nSets are partially ordered in inclusion order.\n\n### Advanced Integers\n\nIntegers have a substructure of (little-endian) sequences of bits. They can be synthesized using the `<:` cons operator, whose left hand side must be a bit (0 or 1), which is shifted into the least significant place, eg: `0<:4 == 8` and `1<:4 == 5`.\n\nIntegers may also be analyzed using the `@` indexing operator, which has a higher precedence than the arithmetic operators, and picks out the bit at that place (`n@0` is the least significant bit of `n`)\n\n### Advanced Strings\n\nStrings have a substructure of sequences of length-1 strings. They can be synthesized using the `<:` cons operator, the `>:` snoc operator, and `:=:`, the splice operator. Cons prepends a length-1 string to the front of the string, snoc appends a length-1 string to the back, and splice concatenates two strings, eg: `\"b\"<:\"elta\" == \"belta\"`; `\"belt\">:\"a\" == \"belta\"`; and `\"bel\":=:\"ta\" == \"belta\"`.\n\nStrings may also be analyzed using the `@` indexing operator, which picks out the length-1 string at that place. (`\"foobar\"@1` == \"o\"`)\n\n### Advanced Lists\n\nLists have a substructure of sequences of items, of any beltabol datatype.  They can be synthesized using the `<:` cons operator, the `>:` snoc operator, and `:=:`, the splice operator, eg: `0<:[\"wang\", []] == [0,\"wang\",[]]`; `[0,\"wang\"]:>[] == [0,\"wang\",[]]`; and `[0]:=:[\"wang\",[]] == [0,\"wang\",[]]`.\n\nLists may also be analyzed using the `@` indexing operator, which picks out the item at that place. (`[0,\"wang\",[]]@2 == []`)\n\n### Advanced Sets\n\nSets have a substructure of unordered collections of elements, of any beltabol datatype. They can be synthesized using the `<:` cons operator and `:=:`, the splice operator. Because of commutativity, the `:>` snoc operator is equivalent to cons on sets. Some examples: `{0,1}:={0,2} == {0,1,2}`; `0<:{1,2} == {0,1,2} == {1,2}:>0`.\n\nSets in general may not be analyzed with the `@` indexing operator, but in the special case of maps being indexed by one of their keys, the operation evaluates to the value corresponding to that key, eg: `{\"nada\":0,\"wang\":1,\"tu\":2}@\"wang\" == 1`.\n\n## User-defined Algebraic Datatypes\n\nUser-defined algebraic datatypes have an constructor, which is an identifier, and arguments of any Beltabol datatype; eg. in `Ptr(s,n)` `Ptr` is the constructor and `s` and `n` are arguments.\n\nExample:\n```\nDa RetBelek imalowda Kuku() | Not(weting,gosh,val,richa).\n\nDa sh(n) im chu\n   \"\"                        detim n?=Kuku();\n   \"(\":=:sh(a):=:x:=:sh(b):=:\")\" detim n?=Not(\"B\",a,x,b);\n   \"<\":=:sh(a):=:x:=:sh(b):=:\">\" detim n?=Not(\"R\",a,x,b).\n```\n\nLimitation: in principle, the algebraic datatypes are totally ordered, but this is currently unimplemented.\n\n## Functions\n\nFunctions can be synthesized via composition with `,`, but they cannot be analyzed: apart from passing them to higher-order functions, the only thing to do with them is to apply them to arguments, either via the high-precedence usual syntax `f(x)`, or via the much-lower precedence `f $ x`. Examples: `(f,g)(x) == f(g(x)) == (f $ g $ x)`\n\n(More pedantically, when we say \"functions\" we are really talking about the *closures* to which they evaluate)\n\nOperators behave like two-argument functions; To use an operator as an identifier, enclose it in parens, eg `(+)`. To use an identifier as an operator, enclose it in backticks, eg `` `mod` ``.\n\n## Compound Expressions\n\nThere are two compound expressions, `chu` compounds and `fong` compounds.\n\n```\n    defn : CHU {cdecl SEMIC} cdecl\n    defn : FONG expr {rdecls SEMIC} rdecls\n```\n\nWhen compound expressions occur as subexpressions anywhere but in top-level statements, they must be fully parenthesized, eg: `2*(chu 2 detim p; 0 detim owta)`\n\n```\nDa div(n,m) im chu\n    (fong (chu [q#1, r-m] detim m<=r;\n               [q#0, r  ] detim owta)\n        wit [q,r] deting div(n,m#0)) detim m<=n;\n               [  0, n  ]            detim owta.\n```\n\n### Chu\n\n`Chu` is like Lisp's COND; each `cdecl` is of the form `expr DETIM guard` and evaluates the expression whose guard is the first to evaluate to 1.\n\nThe match operator, `?=`, which has a low precedence, may be used to extend the expression's environment. It takes a value on its left hand side, and a pattern on its right, and attempts to bind variables in the pattern in such a way as to match the value.\n\nGuards may be composed of multiple clauses, joined by the low-precedence `&&` and operator: ``(x `rep` ys) detim xs?=[x] && len(ys)==1;``\n\n### Example patterns using the `?=` match operator\n\nInteger matching: `0 detim n?=42;` or `m+mul(h,0<:m) detim n?=1<:n;`\n\nString matching: `1 detim arg?=\"-v\";` or `len(h)+len(t) detim s?=h:=:t;`\n\nList matching: `0 detim xs?=[];` or `dfs(graph, h<:seen, acc:>h, vedi(graph,h):=:t) detim vs?=h<:t;`\n\nSet matching: `0 detim xs?={};` or `dfs(graph, seen, acc, t) detim vs?=h<:t && seen?=h<:_ ;`\n\nNote that the clauses of a `chu` expression are always of the form `expression detim guard`.\n\n### Fong\n\n`Fong` is a bit like Lisp's LET; each `rdecl` is of the form `WIT binding DETING expr` where `binding` is bound to the value of `expr`.\n\nWhen there are multiple bindings, each `expr` can see the bindings which come below (after) it.\n\n```\nDu chek (fong cclvi*cclvi\n  wit cclvi deting xvi*xvi;\n  wit xvi   deting iv*iv;\n  wit iv    deting ii*ii;\n  wit ii    deting 2)\nim 65536.\n```\n\nTo define functions, `binding` should be of the form `id(arguments...)`, as in the definition of `nawit(y,xs)` following:\n\n```\nDa nub(xs) im fong (chu\n    h<:nub(nawit(h,t)) detim xs?=h<:t;\n    []                 detim owta)\n    wit nawit(y,xs) deting (chu\n        (chu  nawit(y,t) detim h==y;\n           h<:nawit(y,t) detim owta) detim xs?=h<:t;\n         []                          detim owta).\n```\n\nIn general, what in another language might be written as `let y=z in let v=w in x` would be expressed in Beltabol as `(fong x wit v deting w; wit y deting z)`. Note the change in order!\n\n### Fong/delowda for list comprehensions\n\nUsing `delowda` instead of `deting` turns a `fong` compound expression into a list comprehension.\n\n```\nDa flatten(xss) im fong x\n    wit x  delowda xs;\n    wit xs delowda xss.\n\nDu chek flatten([[0],[],[1,2]]) == [0,1,2].\n```\n\nIn general, what in another language might be written as `[x | y<-z, v<-w]` would be expressed in Beltabol as `(fong x wit v delowda w; wit y delowda z)`. Note the change in order! To produce the effect of a guard, either use a `delowda` clause which evaluates to either a length-0 list for failure or length-1 list for success, or use a refutable pattern in the binding position of the `WIT binding DELOWDA expression` clause.\n\nNote that one can mix `deting` and `delowda` clauses within a single `fong`; the delowdas will act to multiply results but the detings always introduce a single binding (per the delowda's underneath them) only. As is usual with the list monad, a fong comprehension expression produces a flattened list of results, no matter how many delowda clauses it has.\n\n```\nDu chek (fong z\n  wit z deting 2*y;\n  wit y delowda [x+1,x-1];\n  wit x delowda [z+1,z+2];\n  wit z deting 0) im [4,0,6,2].\n```\n\n### Fong/unte for mutual recursion\n\nUse `unte` between `wit` definitions for mutual recursion:\n```\n(fong even(4)\n  wit even(n) deting (chu 1        detim n==0;\n                          odd(n-1) detim owta)\n  unte\n  wit odd(n) deting (chu 0         detim n==0;\n                         even(n-1) detim owta)).\n```\n\n### Fong/imalowda for local algebraic types\n\n```\n(fong dubik(\"\",eg) == gut\n  wit eg         deting [Lit(\"a\"),Ptr(0,5),Lit(\"b\"),Ptr(4,6)];\n  wit gut        deting \"aaaaaabaabaab\";\n  wit dubik(a,c) deting (chu\n        dubik(a<:v  ,              t) detim c?=Lit(v)  <:t;\n        dubik(a     ,              t) detim c?=Ptr(s,0)<:t;\n        dubik(a<:a@s,Ptr(s+1,n-1)<:t) detim c?=Ptr(s,n)<:t;\n              a                       detim owta);\n  wit Mali       imalowda Lit(v) | Ptr(s,l))\n\n```\n\n### Important! Fong Expression Evaluation Order \nIn Beltabol, `fong` expressions (similar to let expressions in other languages) have a unique evaluation order that's opposite to their visual presentation order. \n\n*Key Rule:* bindings in a `fong` expression are evaluated *from bottom to top*, not top to bottom as might be expected from reading order. \n\n```\nDa lookup(table, key) im \n    fong find_in_bucket(bucket, key) // Evaluated Last\n    wit bucket deting table@index; // Evaluated Next\n    wit index deting hash(key). // Evaluated First\n```\n\nThis is to give a top-down overview of the code: emphasizing the forest, not the trees.\n\n## Statements\n\nThere are four statements:\n```\n    statement : DA expr IM defn DOT      \n    statement : DA expr IMALOWDA expr DOT \n    statement : DU CHEK expr IM expr DOT  \n    statement : SHOWXA defn DOT           \n```\n\n1. `Da ... im ...` binds definitions (at the top level)\n2. `Da ... imalowda ...` creates algebraic datatypes\n3. `Du chek ... im ...` is an equality test (run with `--test` option)\n4. `Showxa ...` is used for print debugging\n\nLimitation: Beltabol currently has no I/O; if streams are ever implemented, then probably `Mesach ...` will provide bytestream output)\n\n```\nDa four im 2+2.\nDa peano imalowda Zero | Succ(n).\nDu chek four im 4.\nShowxa Succ(Succ(Zero)).\n```\n\nNote that compound expressions need not be parenthesized when occuring as `defn`s in the `Da/im` and `Showxa` statements, eg:\n\n```\nDa fak(n) im chu\n    n*fak(n-1) detim 1<=n;\n    1          detim owta.\n```\n\nHowever, statements *always* end with `.`.\n\n## Comments\n\nLine comments go from an opening `//` to the end of line.\n\n## Standard prelude\n\n|name|purpose|\n|----|-------|\n|owta| 1 (True)|\n|max(x,y)|**max**imum of **x** and **y**|\n|mebi(f)|returns fn returning x if f(x) fails, otherwise f(x)|\n|walowda(f)|returns fn returning the least fixpoint of **f**(**f**(...**f**(x)...))|\n|sqrt(n)|integer square root of **n**||\n|mod(i,j)|i **mod** j|\n|len(v)|length of **v**alue|\n|chr(n)|length-1 string with numeric value **n**||\n|ord(c)|numeric value of length-1 string **c**|\n|unit(v)|returns empty string or list as **v** is string or list||\n|(**)(b,e)|raises int **b**ase to **e**xponent|\n\n## See also\n\nSee the [other docs](bb.md) and the [brief introduction](https://drive.google.com/file/d/1zTGjy9KeW4cqagXHlVDwKmcZ1mEz6u-K/view).\n",
      "task": "Please write Kosaraju's algorithm.\nPlease use `Du chek` to check your program",
      "program": ""
    }
  ],
  "signature": {
    "instructions": "Generate program source.",
    "fields": [
      {
        "prefix": "Target:",
        "description": "Documentation for the target language"
      },
      {
        "prefix": "Task:",
        "description": "The algorithm we want code for"
      },
      {
        "prefix": "Program:",
        "description": "The generated program"
      }
    ]
  },
  "lm": null,
  "metadata": {
    "dependency_versions": {
      "python": "3.13",
      "dspy": "3.0.3",
      "cloudpickle": "3.1"
    }
  }
}
